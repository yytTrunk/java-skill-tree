# 设计模式



## 为什么需要设计模式

真正好的代码不只为了完成现有功能，更会考虑后续扩展

高内聚，低耦合

设计模式简化了代码的开发，给后续的需求迭代增加了很好的扩展性。

设计模式就是基于六大原则，进行的代码设计。

模仿-优化-实现

设计模式的使用是为了让代码更加易于扩展和维护，不能因为添加设计模式而把结构处理得更加复杂甚至难以维护。

要想合理地使用设计模式，需要大量的实际操作经验。

## 什么是六大原则

### 单一职责

#### 是什么

#### 作用是什么



### 开放-封闭原则

#### 是什么

#### 作用是什么



### 里式替换原则

#### 是什么

#### 作用是什么



### 迪米特原则

#### 是什么

#### 作用是什么



### 接口隔离原则

#### 作用是什么

一个类对另一个类的依赖应该建立在最小的接口上，**尽量将臃肿庞大的接口拆分成更小的和更具体的接口**。



#### 原则是什么

1. 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑
2. 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法
3. 提高内聚，减少对外交互

### 依赖倒置原则

#### 是什么

高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象

#### 作用

降低了类之间的耦合，提高了系统的稳定性和可维护性



## 哪些设计模式

| 类型       | 模式         | 作用                                                         | 可使用场景                                                   | 使用频率 |
| ---------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 创造型模式 | 工厂模式     |                                                              |                                                              |          |
|            | 抽象工厂模式 |                                                              |                                                              |          |
|            | 单例模式     |                                                              |                                                              |          |
|            | 建造者模式   |                                                              |                                                              |          |
|            | 原型模式     |                                                              |                                                              |          |
|            |              |                                                              |                                                              |          |
| 结构型模式 | 适配器模式   |                                                              |                                                              |          |
|            | 桥接模式     |                                                              |                                                              |          |
|            | 组合模式     |                                                              |                                                              |          |
|            | 装饰器模式   |                                                              |                                                              |          |
|            | 外观模式     |                                                              |                                                              |          |
|            | 享元模式     | 通过共享通用对象，减少内存的使用，提升系统的访问效率         | 1. 商品秒杀场景中使用享元模式优化查询                        | ★★       |
|            | 代理模式     | 为了方便访问某些资源，使对象类更加易用                       | 1. mybatis基本功能接口定义，不需要写实现类                   | ★★★★     |
|            |              |                                                              |                                                              |          |
| 行为型模式 | 责任链模式   | 解决一组服务中的先后执行关系                                 | 1. 出差审批 2.netty框架的pipeline                            | ★★★★     |
|            | 命令模式     | 把逻辑实现与操作请求分离，将命令对象用构造函数的方式传递给调用者 | 1. 点菜场景                                                  | ★★       |
|            | 解释器模式   | 不改变原有类的基础上给类新增功能                             | 1. 单点登录权限扩容                                          | ★★★★     |
|            | 迭代器模式   | 以相同的方式遍历不同的数据结构元素                           | 1.数组、链表元素遍历等                                       | ★★       |
|            | 中介者模式   | 当复杂功能应用之间重复调用时，在中间添加一层中介者包装服务，对外提供简单、通用和易扩展的服务能力 | 1.中台系统包装接口和提供统一服务 2. 中间件，包装底层多种数据库差异，对外听简单调用 | ★★★★     |
|            | 备忘录模式   | 以不破坏原对象为基础增加备忘录操作类，记录原对象的行为       | 1. 编辑、撤销功能 2. 回滚版本                                | ★★       |
|            | 状态模式     |                                                              |                                                              |          |
|            | 策略模式     |                                                              |                                                              |          |
|            | 模板方法模式 |                                                              |                                                              |          |
|            | 观察者模式   | 当一个行为发生时，一个用户传递信息，另一个用户接收信息并做出相应的处理，行为和接收者之间没有直接的耦合关联 | 1.MQ服务扩展，拆分核心流程与辅助流程的代码                   | ★★★★     |
|            | 访问者模式   |                                                              |                                                              |          |





### 工厂模式

#### 作用

定义一个创建对象的接口，让其子类自己决定将哪一个工厂类实例化，工厂模式使创建过程延迟到子类中进行

#### 实现方式



### 抽象工厂模式



### 建造者模式



### 原型模式

#### 作用

解决创建重复对象的问题

#### 不足

使用频率不高



### 单例模式

#### 作用

一个全局使用的类在使用时，避免被频繁地创建与销毁，从而提升代码的整体性能。

#### 实现方式

##### 静态类使用

##### 懒汉模式

##### 饿汉模式

##### 懒汉模式-双重校验

##### CAS-AtomicReference

##### 枚举单例（推荐）



### 适配器模式

#### 作用

原本不兼容的接口通过适配修改做到统一，方便调用方使用。

如何针对多种差异化类型的接口实现统一输出。

#### 常见场景

在业务开发中，经常需要做不同接口的兼容，尤其是中台服务。中台需要把各个业务线的类型服务统一包装，再对外提供接口。



### 桥接模式

#### 作用

通过将抽象部分与实现部分分离，将多种可匹配的使用进行组合

#### 常见场景

包括 JDBC 多种驱动程序的实现、同品牌类型的台式机和笔记本电脑、业务实现中的多类接口同组过滤服务等





### 组合模式





### 装饰器模式





### 外观模式

#### 作用

降低调用方使用接口时的复杂逻辑组合。在调用方与实际的接口提供方之间添加了一个中间层，向包装逻辑提供API接口。

#### 常见场景





























